Lesson 5

--PostgreSQL

1. Запрос, который выберет категории и среднюю цену товаров в каждой категории, при условии, что эта средняя цена менее 1000 рублей (выбираем "бюджетные" категории товаров)

 Сначала посмотрим средние цены в категориях:

sql> SELECT CAST(AVG(price) AS NUMERIC(7,2)) AS average_price,
COUNT(cats.id) AS number_of_books,cats.name FROM cats
INNER JOIN products
ON cats.id = products.cat_id
GROUP BY  cats.name
[2018-06-01 15:12:03] 5 rows retrieved starting from 1 in 38ms (execution: 7ms, fetching: 31ms)

average_price | number_of_books | name
977.40	        5	              История
136.67	        3	              Медицинская литература
349.67	        3	              Детективы
1217.40	        5	              Научная литература
1440.57	        7	              На иностранных языках

 Выберем категории со средней ценой меньше 1000

 sql> SELECT CAST(AVG(price) AS NUMERIC(7,2)) AS average_price,
COUNT(cats.id) AS number_of_books,cats.name FROM cats
INNER JOIN products
ON cats.id = products.cat_id
GROUP BY  cats.name
HAVING  AVG(price) < 1000
[2018-06-01 15:19:21] 3 rows retrieved starting from 1 in 47ms (execution: 31ms, fetching: 16ms)

349.67	3	Детективы
977.40	5	История
136.67	3	Медицинская литература

2.   "Улучшите предыдущий запрос таким образом, чтобы в расчет средней цены включались только товары, имеющиеся на складе."

sql> SELECT CAST(AVG(price) AS NUMERIC(7,2)) AS average_price,
COUNT(cats.id) AS number_of_books,cats.name FROM cats
INNER JOIN products
ON cats.id = products.cat_id
WHERE products.quantity > 0
GROUP BY  cats.name
HAVING  AVG(price) < 1000
[2018-06-04 09:08:41] 3 rows retrieved starting from 1 in 49ms (execution: 25ms, fetching: 24ms)

349.67	3	Детективы
977.40	5	История
136.67	3	Медицинская литература    -- Результат ничем не отличаеся от предыдущего, что не удивительно, поскольку в таблице products нет   нулевых значений для quantity. Попробуем  в расчет средней цены включить только книги, имеющиеся на складе в количестве больше 1000:


ql> SELECT CAST(AVG(price) AS NUMERIC(7,2)) AS average_price,
COUNT(cats.id) AS number_of_books,cats.name FROM cats
INNER JOIN products
ON cats.id = products.cat_id
WHERE products.quantity > 1000
GROUP BY  cats.name
HAVING  AVG(price) < 1000
[2018-06-04 09:17:59] 4 rows retrieved starting from 1 in 28ms (execution: 18ms, fetching: 10ms)

173.00	1	Медицинская литература
349.67	3	Детективы
757.67	3	Научная литература
768.67	3	На иностранных языках


3. Добавьте к таблице брендов класс бренда (A, B, C). Например, A - Apple, B - Samsung, C - Xiaomi. Напишите запрос, 
который для каждой категории и класса брендов, представленных в категории выберет среднюю цену товаров.

sql> ALTER TABLE publishers ADD COLUMN class CHAR(1)
[2018-06-04 13:04:29] completed in 410ms


sql> SELECT  c1.id,c1.name AS category, p1.class AS class,
  cast((SELECT AVG(pr2.price)
   FROM (products pr2
      JOIN  cats c2 ON  pr2.cat_id = c2.id)
         JOIN publishers p2  ON   p2.id = pr2.publisher_id
    WHERE c2.id = c1.id
    AND p2.class = p1.class
  ) AS NUMERIC(10,2)) AS avg_price
FROM (products pr1
 JOIN  cats c1 ON  pr1.cat_id = c1.id)
   JOIN publishers p1  ON   p1.id = pr1.publisher_id
  GROUP BY c1.id,p1.class
  ORDER BY c1.id,p1.class
[2018-06-07 09:23:04] 13 rows retrieved starting from 1 in 254ms (execution: 228ms, fetching: 26ms)


1	История	                A	1077.25
1	История                	B	578.00
1	История         	       C	1558.50
2	Научная литература	     B	1199.50
2	Научная литература	     C	11235.00
3	На иностранных языках  	A	514.60
3	На иностранных языках	  B	3755.50
3	На иностранных языках	  C	6916.00
4	Детективы              	A	349.67
4	Детективы           	   C	349.67
5	Медицинская литература 	A	173.00
5	Медицинская литература	 B	118.50
5	Медицинская литература	 C	458.00



Для проверки сделаем запрос:

sql> SELECT AVG(products.price),publishers.class
FROM ((products INNER JOIN cats ON products.cat_id = cats.id)
  INNER JOIN publishers ON publishers.id = products.publisher_id
)
WHERE cats.name = 'История'
GROUP BY publishers.class
[2018-06-05 16:02:42] 3 rows retrieved starting from 1 in 27ms (execution: 13ms, fetching: 14ms)

avg     class
1077.25	A
578	    B
1558.5 	C

4. Добавим к своей базе данных таблицу заказов. Простейший вариант - номер заказа, дата и время, ID товара.

sql> CREATE TABLE orders (
  id         SERIAL PRIMARY KEY,
  order_id INTEGER,
  date       TIMESTAMP(2),
  product_id INTEGER,
)
[2018-06-05 09:50:31] completed in 602ms

sql> ALTER TABLE orders ADD FOREIGN KEY (product_id) REFERENCES products(id)
ON UPDATE CASCADE
ON DELETE RESTRICT
[2018-06-05 10:41:20] completed in 193ms

5. Напишите запрос, который выведет таблицу с полями "дата", "число заказов за дату", "сумма заказов за дату". Для этого вам придется самостоятельно найти информацию о функциях работы с датой и временем.

sql> SELECT  DISTINCT DATE(od1.date),
  (SELECT COUNT(DISTINCT od2.order_id) FROM orders od2
  WHERE DATE(od2.date) = DATE(od1.date)),
  (SELECT SUM(products.price)
   FROM orders od2
     INNER JOIN products ON od2.product_id = products.id
   WHERE DATE(od2.date) = DATE(od1.date)
  )
FROM orders od1
GROUP BY od1.date
[2018-06-07 11:04:28] 4 rows retrieved starting from 1 in 83ms (execution: 49ms, fetching: 34ms)

2018-01-10	 1	 468
2018-01-11 	2	 4119
2018-01-12 	3	 3633
2018-01-13	 3	 12649


